# -*- coding: utf-8 -*-
"""Assignment-2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cyIKu4b8QD_A0oeaFugYmQo-MizxOjWw

### ## BBM 409 - Programming Assignment 2

* You can add as many cells as you want in-between each question.
* Please add comments to your code to explain your work.  

* Please be careful about the order of runs of cells. Doing the homework, it is likely that you will be running the cells in different orders, however, they will be evaluated in the order they appear. Hence, please try running the cells in this order before submission to make sure they work.    
* Please refer to the homework text for any implementation detail. You should also carefully review the steps explained here.
* This document is also your report. Show your work.

# **Gökdeniz Şimşek - 2210356067**

# 1. LOGISTIC REGRESSION TASK (40 points)

### 1. Data Loading and Exploration

##### Download the Bank Marketing dataset from https://drive.google.com/file/d/1t6QAtqfYLMhvv_XUnG4D_UsJcSwgF4an/view?usp=sharing  import other necessary libraries
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import classification_report, confusion_matrix

df=pd.read_csv("portuguese_bank_marketing_numeric_random_subsampled.csv", encoding="utf-8")

print("Dataset Head:")
print(df.head())

print("\nDataset Info:")
print(df.info())

print("\nDataset Description:")
print(df.describe())

"""### 2. calculate correlation between target variable 'y' and other features (5 points)"""

correlation_matrix = df.corr()
target_correlation = correlation_matrix['y'].sort_values(ascending=False)

print("Correlation between 'y' and other features:")
print(target_correlation)

"""# 1.1 Implementing Logistic Regression with most correlated 2 features

###  Choose the two most correlated features with target feature 'y'
"""

X = df[["duration", "poutcome"]]
y = df['y'] - 1 # for normalization (if true_y value is 1, it will be 0; if else it is 2, it will be 1)

print(y)

print("Dataset X Head:")
print(X.head())

print("\nDataset X Info:")
print(X.info())

print("\nDataset X Description:")
print(X.describe())

print("\nDataset y Head:")
print(y.head())

print("\nDataset y Info:")
print(y.info())

print("\nDataset y Description:")
print(y.describe())

"""###  * Define your logistic regression model as class without using any built-in libraries
### * Define necessary functions such as sigmoid, fit, predict  (10 points)
"""

# Sigmoid function
def sigmoid(z):
    return 1 / (1 + np.exp(-z))

# Logistic Regression class
class LogisticRegressionScratch:
    def __init__(self, learning_rate=0.01, iterations=1000):
        self.learning_rate = learning_rate
        self.iterations = iterations

    def fit(self, X, y):
        # Start weight and bias
        self.weights = np.zeros(X.shape[1])
        self.bias = 0

        # Gradient descent
        for i in range(self.iterations):
            # Lineer model: z = w^T * X + b
            linear_model = np.dot(X, self.weights) + self.bias

            # Prediction: sigmoid(z)
            y_predicted = sigmoid(linear_model)

            # Gradients
            dw = (1 / len(y)) * np.dot(X.T, (y_predicted - y))
            db = (1 / len(y)) * np.sum(y_predicted - y)

            # Updating weight and bias
            self.weights -= self.learning_rate * dw
            self.bias -= self.learning_rate * db

    def predict(self, X):
        # Lineer model: z = w^T * X + b
        linear_model = np.dot(X, self.weights) + self.bias
        y_predicted = sigmoid(linear_model)
        # Predicted class
        return [1 if i >= 0.5 else 0 for i in y_predicted]

"""Split the dataset into a training set and a validation set (80% training and 20% validation)."""

X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2, random_state=42)

print(f"Train set: {X_train.shape}, {y_train.shape}\nTest set: {X_val.shape}, {y_val.shape}")

"""Scale the features using StandardScaler"""

scaler = StandardScaler()

X_train = scaler.fit_transform(X_train)
X_val = scaler.transform(X_val)

print("Features are standardized.")

"""* Initialize and train the custom logistic regression model"""

# Start the Logistic Regression model
model = LogisticRegressionScratch(learning_rate=0.01, iterations=1000)

# Train model
model.fit(X_train, y_train)

print("Model trained succesfully")

"""* Make predictions on the validation set"""

y_pred = model.predict(X_val)
print(y_pred[:10])
print(y_val[:10])

"""### Evaluate the model's performance, print classification report and confusion matrix  (5 points)"""

def calculate_accuracy(y_true, y_pred):
    # Check and count correct guesses
    correct_predictions = sum(y_t == y_p for y_t, y_p in zip(y_true, y_pred))
    # Calculate the Accuracy
    accuracy = (correct_predictions / len(y_true))
    return accuracy

def calculate_confusion_matrix(y_true, y_pred):
    tp = 0  # True Positives
    tn = 0  # True Negatives
    fp = 0  # False Positives
    fn = 0  # False Negatives

    for true, pred in zip(y_true, y_pred):
        if true == 1 and pred == 1:  # True 1, Pred 1
            tp += 1
        elif true == 0 and pred == 0:  # True 0, Pred 0
            tn += 1
        elif true == 0 and pred == 1:  # True 0, Pred 1
            fp += 1
        elif true == 1 and pred == 0:  # True 1, Pred 0
            fn += 1

    return tp, tn, fp, fn

def evaluate_model(y_true, y_pred):
    # Accuracy
    accuracy = calculate_accuracy(y_true, y_pred)
    print(f"Accuracy: {accuracy:.4f}")

    # Confusion Matrix
    tp, tn, fp, fn = calculate_confusion_matrix(y_true, y_pred)

    print("\nConfusion Matrix:")
    print(f"[TP: {tp}  FP: {fp}\n FN: {fn}  TN: {tn}]")

    # Precision, Recall ve F1-Score
    precision = tp / (tp + fp) if (tp + fp) > 0 else 0
    recall = tp / (tp + fn) if (tp + fn) > 0 else 0
    f1_score = 2 * (precision * recall) / (precision + recall) if (precision + recall) > 0 else 0

    print("\nClassification Report:")
    print(f"Precision: {precision:.4f}")
    print(f"Recall: {recall:.4f}")
    print(f"F1-Score: {f1_score:.4f}")

# Evaluate the model on the validation set
evaluate_model(y_val, y_pred)

"""### Print decision boundaries as in PA1 (5 points)"""

def plot_decision_boundary(X, y, model):
    # Minimum and maximum values ​​for plotting the graph
    x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1
    y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1

    # Prepare a grid to create the decision boundary
    xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.01),
                         np.arange(y_min, y_max, 0.01))

    # Make predictions for all grid points
    grid = np.c_[xx.ravel(), yy.ravel()]
    predictions = np.array(model.predict(grid))
    predictions = predictions.reshape(xx.shape)

    # Draw the data and decision boundary
    plt.figure(figsize=(10, 6))
    plt.contourf(xx, yy, predictions, alpha=0.6, cmap=plt.cm.Paired)
    plt.scatter(X[:, 0], X[:, 1], c=y, edgecolor='k', cmap=plt.cm.Paired)
    plt.title("Logistic Regression Decision Boundary")
    plt.xlabel("Feature 1: duration")
    plt.ylabel("Feature 2: poutcome")
    plt.show()

# Draw the decision boundary on the training set on which the model was trained
plot_decision_boundary(X_train, y_train, model)

"""# 1.2 Implementing Logistic Regression using all features.

* Redefine input and target variables. In this experiment, you will use all input features in the dataset.
"""

X_all = df.iloc[:, :-1]  # X Features: all columns without the last column
y_all = df.iloc[:, -1] - 1   # y Target: last column (with normalization)

print(y)

print("Dataset X Head:")
print(X_all.head())

print("\nDataset X Info:")
print(X_all.info())

print("\nDataset X Description:")
print(X_all.describe())

print("\nDataset y Head:")
print(y_all.head())

print("\nDataset y Info:")
print(y_all.info())

print("\nDataset y Description:")
print(y_all.describe())

"""* Split the dataset into a training set and a validation set (80% training and 20% validation)."""

X_train_all, X_val_all, y_train_all, y_val_all = train_test_split(X_all, y_all, test_size=0.2, random_state=42)

print(f"Train set: {X_train_all.shape}, {y_train_all.shape}\nTest set: {X_val_all.shape}, {y_val_all.shape}")

"""* Scale the features using StandardScaler"""

scaler = StandardScaler()

X_train_all = scaler.fit_transform(X_train_all)
X_val_all = scaler.transform(X_val_all)

print("Features are standardized.")

"""### Initialize and train the custom logistic regression model."""

# Start the Logistic Regression model
model = LogisticRegressionScratch(learning_rate=0.01, iterations=1000)

# Train model
model.fit(X_train_all, y_train_all)

print("Model trained succesfully")

"""* Make predictions on the validation set"""

y_pred_all = model.predict(X_val_all)
print(y_pred_all[:10])
print(y_val_all[:10])

"""### Evaluate the model's performance, print classification report and confusion matrix  (5 points)"""

# Evaluate the model on the validation set
evaluate_model(y_val_all, y_pred_all)

"""### Briefly explain the impact of the number of features on the learning ability of the model. (5 points)

The number of features in a dataset significantly affects a machine learning model's learning ability. Too many features can lead to the curse of dimensionality and increase the risk of overfitting. Conversely, features that are too few may result in underfitting. Striking a balance is crucial, as excessive feature reduction might discard important information.

### After completing the SVM and logistic regression tasks, the best results of the experiments with the SVM and Logistic regression models will be compared in a table. (5 points)

![table.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA3cAAAD1CAYAAADzowxYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAHzVSURBVHhe7d0JvG9T/f/xfZExkSJuydwgXUpCFNFApJBSSinSZKh+FZqLEk1KhQwlDShkatYoMo8NSkWhaDaL7v//XJ112nff7/fM5957jvfr8diPc77fPe+91mde6ztjtdVWm33vvfc2d9xxR7Pqqqs2K6ywQrPMMss0Cy+8cBNCmDfcd9996XMhhBEReRFCCAH0wT//+c/mggsuaJZccslmkUUWaWastNJKs5dYYolm1qxZ5csbb7yxbPSf//xnYLcQwmRy++23N5tssklz7rnnNksttdTAtyGEMDeRFyGEEGbPnt0stthixblbdtllm6WXXrq58sormzvvvLOZsfrqq8+mKG666aaycPREBGfMmDGwewhhMtER11tvveayyy4r/S+EEPoReRFCCAE1EacCc/nlly/VlwJ/C8nYcepuvvnm4vWVdF4cuxBCCCGEEEJYIFlooYXKsuiiizY33HBD8eX4dQspxeTc+RtCCCGEEEIIYerAj7vllltKuf5CxtiltCOEEEIIIYQQph41i/f73/++WcjkKZl1K4QQQgghhBCmJpy7u+66q1nIYLyMsQshhBBCCCGEqUvJ4A38H0IIIYQQQghhCsKxu/vuu+PchRBCCCGEEMJURzVmnLsQQgghhBBCmAbEuQshhBBCCCGEaUCcuxBCCCGEEEKYBkxb586Awr/85S/NbbfdNvBNCCGEEOYn//rXv5q//e1vzb333jvwzdig2+l4uj6Mjol6ByGEBZOFV1xxxfc84AEPGPg4ev70pz81N998c/P3v/+9ufXWW5tFFlmkWXTRRQfW/g/CxLYEit/WM6PLYostNrB2YiHsXcPrX//6xk89XHnllc3SSy89sDaEBQsK9v/3w9I/xtMXoX8xePzVJ//xj3+U/nbPPfc0d9xxR+mrvjPgdvHFFx/Y639Y/+c//7kYTq7F/47nWLfffnuz5JJLlr7bxflc/3ByIIQwPiZKXlTdrV8/6EEPGvh2cvHjujvttFOz2WabNT/60Y+KDdBLngwHufSUpzyleeELX9hcccUVRb6ROWPhj3/846CMqwsZSV5isuyU+cVEvYMQ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IQPq8o9//KM4YO94xzvKX/u/9a1vHXTK7DOUvGAz7LjjjiVA7Bqe8pSnlHOieywLedXvWCGEcH9nQpy7e++9t1l88cWbJz3pSc2MGTOa//znP80TnvCEZosttmjuvPPOga1CCJMF42iPPfZojjrqqObyyy8vEfQXvvCFzZJLLtkcffTRzbbbbjtoLLVhIHHa1llnneaNb3xj2c/+9vnABz4waKjJEiy88MLN0ksvXbY56aSTmmc961lx8EKYgoxWXsiinXvuuc0aa6wxKAPaC4fs97//fXHCQHa8/e1vby666KKyft999y32AFnTS17I2HHuHJsNMXv27PI9+VOPdeqpp5ZjkVPkVb9jhRDC/Z0Jce4oAYpi1VVXLf/fcccdpaxi0003naNMM4QwOTCOdtppp+aGG25oPvGJT5T+981vfrM57rjjmoc97GElQi+63obh9MEPfrAYSscff3xzzDHHlP3sz1DbaqutSpR80UUXLQbguuuuW0qhLLvvvnuJnj/mMY9pnve85/V0HEMICyZjkRccvNr/60I2kBvrr79+CfRwvsgMsoMMqce2zec+97nm8Y9/fHPwwQcX2VOpjuZGG21UAsNt6rE4cmSOczoWeeVYNQAVQgjhf0yIc0dREO5LLLFEifBbZPKUd3QVBJRuirh1lwph32u9LGD7c5vu9zXjYPnLX/4y+L9j9zu+79v02669tI1ada71e+UlIcwLtMHtttuuOFo///nPm7POOqsYYoyqCy64oJRMr7fees0999wzsMd/EXhhyN13331lLA3DzH72bxtMD3/4w5tXvepVxbBqo18Zm7fSSiuV7H0IYcFnrPKiF7ax7aWXXtoccMABRe9zDB/60IcWGVKPTbaQMWROzcpV2A8veMELmuuuu6658sorm0UWWaR8b/s999yzefSjH12Oz5EEmXPhhRcWe4DdwQEMIYTwP8bt3HFoOHEEPCOR0LUw9gz6fu5znzuHA8TxecMb3tBcddVVxTjk/Pn7gx/8YNAx2nnnnYuSIdxrLb/I3Zprrtl8+9vfLk5XuyTD3/q9vz5TNPa75pprSqmIKKKxBaKVjn/++eeXz47P2VRWIjLYPmav61BmQmH57Niije7Pc2DkynBY98lPfjIOXpgnMJg23njjZsUVVyyGWTWCGFWnn356MZ4YW89//vPn6IsMsT//+c+l3JJhx0iyfptttmmWX3750i8rHLwujDQlVCGEqcNY5UUX+lDmTEb/sssuK8dxDOWTZIeJVcgSxyBbyJgHPOABRRdXB46ePeigg0qJ92mnnVacwDYbbrhhkU90MHkF+5Jbzu86QwghzMm4nTslmBy4mTNnFufq6quvLgthTvA+7WlPK9uAIFeasf/++5csACXzq1/9qgjpBz7wgWUbyuJDH/pQs/baaxfDkdOldIRgJ/iVbRD23fINnwn9+n3786677locL8YoB/QlL3lJGRPI+frlL39ZnDsZjLe85S3NK1/5ynKd/a5DdtI1//vf/y7KinPnPixPf/rTm0c84hHF0eM8UnQhzAu0be2ubQRVbrnllrK+22cYX/qiQIs+Ijtn/7333ru045NPPrlEybsw1rbeeuvSNwQ4jjjiiLlm1gwhLLiMRV50oeOf/exnNzfeeGNx6JZddtnyPT2txNMwDbLEOcgWuvWHP/xhc+SRRxZ5UQNJ1gnKvvvd754rW+g66Nq2Q0ivfv3rXy9OaAghhLkZt3MnS8VRMiUzQ+/EE08si/85YdbddtttRREQ7oxCSuN73/teMSBF5pRdmIxF9M6gas6U8gyfN9hgg5IBZEieffbZA2cdGc7DaXNug8U5eAaLUzAvetGLyrVxztT7iwRScq5j880373sdj3vc45o3velNZdYwUUhZS8enaByP4rGPcQHdKGQIk4n+1g+BFgGYbvkk500bVkr9sY99rLRlY2U5e5/97GfnctoEcBhrBx54YOlPn/70p3s6gCGEBZuxyIsKOaBk8rGPfWxxzM4888zBYKagkcqZ97znPWUSFTLl4x//eBmTxxms8qIGkmBsXj/oYUsvVBgoAx0qwxhCCPc3xuXcEaiydpweETclixX/+05dv/JG2TkOEgWgFISwJ5jrwOwHP/jBxdFTKkJxiO7JkNX1ltFCIYj8nXTSSSXS5xiU1qc+9anmmc98ZnPeeeeVLJ1yENdSYewOdR3u4cc//nFxHn1+xjOeUbJ2HEMZvB/96EeDUcwQ5hWy0v1QJiXCXqPf0L532GGHEtiQvRaMsHDyTjjhhLlmwvR/nTrdJCyHHHJICZYkaxfC1GO08qKNYCZ9DsMw2gEecoLs4Ny95jWvKTLFLJiCQWSHwKltyA6BU4FQQx36QYdbeiHLKGtYHcsQQgjjdO6UWyq7JNgpite97nXFSLT4n/NDsNsGavIXWmihksk755xzBksxYX8ljxwyx22Xao4V55JZVHamhJLjtfrqq5dxBcbXiTpSYjKCtnNu1yyiOdR1+CxaqaxTZtCYA1k7/1M2nMaJ+mH4EEaC9iqTXNt5G4EL6/WHNgw0/VQ79xuV9hWs8FtVjLOnPvWpJTrPCWSMydYxyPxmlRkybWf7EMLUYizyoiKoq//Lwv3iF78YLLMEfWkG3i233LLICo4bGcFGEFSlO1/84hc3r3jFK0r1DN3rZw4q9C9boH1NrlOJZ80i1vOnYiCEEHozLueOk8apoQhE1jhIDEWL/2vEzTZt/JbOZpttNlcpheNYOHkyX8YE9KMbyaMAekFZWKA8xHg7ZaCyFaKKoo/HHntsyTI6NzhmQ12H6//Od75TJltRyukYZu3yv++ss00I8wLRdWNSjE1R6lzHrehfZsVjBAliyFDXCLd1vWa1g4CMaDwYZpxARhojzERGa621Vvkbxy6EqcdY5EUbTpZApu3as1iCU2adYyu7JEvA+ePscQZXXnnl4uDRy34YnV6uC92srNOYPXrUWHe6uO2E1vPbznWGEEKYkzE7dxw75ZbKLkX4vvKVrxRFYVY9i/8///nPl21F3YzhMa6HgCbcZc4IfxkBC8FOUcgSUAS77LJLUQx1vQXKOgh7wl3kz/fq9pWJ9SozqQ4bKBzlITJzFJpzwhg7ioKyofhMDz3UdVCCFBsD13TMylI5sPaRkXSsEOYV2qnouXGu+mOdoU7/evKTn1z6W53NzqRA2rDgS69Z7aBfCFjoD7b1g8bKp7R3QQxOXcqgQpiajEVe+Fuh+20Hwcx2ZYsAZ3cGXtCNdL7z/fa3vy1ZP9cheEq/1qVOsOa37QydoIsdr/3TDLUklAzyW5v2CyGE8D/G7NwR1sotCWhlWsbYMRIZfhalHaL/1nGoZOqUfplFUpZN1uD6669vfvaznxWBbv+TTjqp+e53v1ucRZM6+M4xOIUifqKKfmqAk+a8BmET7ma1pHCGgxIyEYr9ZSwOP/zwcvy99tpr0DHk3J1yyilDXodoI+UlEunaObIWStC+ydqFeQ0DRynlKqusMjhDHQPJTHTarb8ws6U+6S+6s9ppw8ovGV+MP0ag9m5M7BlnnFH2sU13CSFMHcYiL6qDx8kSzLQPx6s9Lo8NUGfgVXrpOOQDh+y1r31tcRirQ1ZthbqAzqVbOYmcQ0MoZPAElehbx3JMk7PR0SZuSTA1hBDmZEzOnbIIAtUEIqL7fnzUTxy0I2gcKdk8zg/HSaRNtO85z3lOEdLGpnH6lGFw1CgKUAhq9o1nI+SVgJncRIZBlsxkD87FuVQ+Kcr4jW98oxiiSjXrOAF/OXGur2bvnMdPHJjN07Fk32QAv/CFL5Rxgra1HwU01HVwJH3nvsy86a9zm2SF4msruxDmBfojQ8dvRumXIuZ+ykD7NUFQNZ7aaOf2EVE3btQ+ln322aeUYdpPn9Z/ZNzf+MY3Dm5TF4YfIysOXghTh7HIC8jwCczKuMn+m6ism8W3r2OoYjFxWpUTZImxckM5ZPQq+6LqbMfizJFHKnUcyzHJHAGoftcZQgj3Z2bMnDlz9lgm/yCA//CHPwx8+q8Q7kXb6DO1MuGt7MK4vC71GJQGZ6sL58o4OI5gLSHrheM4B0UAEcC2AjILWHscHSO3lnz4v/5g83DX4d4++tGPFuUjgvn617++RD2TuQujQVtU2qvtjHcinna7r7T7pui7tt5u5wIlIutt2ut7HbNLjKwQ5g3zW17UEk4M1e97BXy6urhL3ae7Xb2ONpE5IYQwN3TEmJ27+zMMYQaxbMcXv/jFMgOnWb9e8IIXROGEUTORxloIYXoTeRFCCKEfdMS4Zsu8P8Kx22+//cqAc+WgHDtRTKWioo0hhBBCCCGEMD+IczdKjK0zHsBYP6UqZvj0kwpnnnnmkOUmIYQQQgghhDCZpCxzDHTHKQw3jiCEoUiZVQhhpERehBBC6EfKMseImb6MratLHLsQQgghhBDC/CbOXQghhBBCCCFMA+LchRBCCCGEEMI0IM5dCCGEEEIIIUwD4tyFEEIIIYQQwjQgzl0IIYQQQgghTAPi3IUQQgghhBDCNGDGMsssMztT+Ycw/7j99tubjTfeuDnvvPPysxohhCGJvAghhNAPOmLGVlttNXvgcwhhPnHPPfc0iy666MCnEELoT+RFCCGEfiRzF8J8JpH4EMJIibwIIYTQj5K5mzlz5uzFFlts4KsQwrzm7rvvbmbNmtVcccUVTfpiCGEoIi9CCCH0g47IhCohhBBCCCGEMA2IcxdCCCGEEEII04A4dyGEEEIIIYQwDYhzF0IIIYQQQgjTgDh3IYQQQgghhDANiHMXQgghhBBCCNOAOHchhBBCCCGEMA2IcxdCCCGEEEII04A4dyGEEEIIIYQwDYhzF0IIIYQQQgjTgGnj3N12223NX/7yl+aee+4Z+GZobGd7+00l/vrXvza/+93vmhtuuGHgmxBCCCGEEEJomhkzZ86cvdhiiw18HD0cjX485CEPaR70oAcNfJo8brzxxua5z31us9FGGzVHHXVUc/vttzeLLrrowNq54dgttdRSzatf/erm/PPPb7761a82q6222sDaeQMn7V//+lf5v31u137zzTcPfJqbgw8+uFz317/+9WbPPfdsHv7whw+smX9wND3Teh/97i305u67725mzZrVXHHFFc14+iL++c9/Nn/7298GPv2XFVZYobT3LsO1Nei/+jHqe26T9xvCvGWqyIu2Hqh05UU/+4H+rrqt13Eq/a41hBDur9AR48rcEczf/va3m3/84x/N3//+98Hlz3/+c3PBBRc0z3/+84d0/iaCO++8s3na057WHHLIIc0+++zTHHbYYcNmtaw/9NBDy/Yf//jHm2233ba54447BtZOPp7J2972tvKsvve97w0+I3+f+MQnNr/+9a+bW2+9tSi0uvjOdd51113NEkss0fznP/8p+8xvXPNnPvOZYmj4nyJ+xzveUe7tW9/61uC9hcnHs95+++2bP/3pT3O0G22q+x4Yaptssklz7bXXztXWLPp0fZf+2v/Tn/704Lb+5v2GMHWZbHnx1re+tfxvfS954f9LLrmkOJjtY6mmEaSlp+1/wAEHlCqb9naO51pck2sLIYTwP8ZdlsnJmDFjRvPvf/+7CFkL5+Oxj31scbj23XffIpQni4UWWqgc/5ZbbilC/6abbhoyawfrq9L54x//WKKRCy+88MDaycXz4aS94hWvKA7wlltuWaKZFB3l941vfKP57W9/2yy99NIlCmp505veVJxPz3lBwfVaLr744ualL33pYEZH1JZS/9SnPtU885nPbD7wgQ+UZx0mF31gjz32KEbR5ZdfXtrNC1/4wmbJJZdsjj766NLm2kaQaPe5557brLHGGnO0tbow8n7/+9+Xd6mfaJuvetWrSvDEev36Gc94Rhy8EKYgkykvQO6//e1vby666KKynrzYYostijPXlhezZ88u+7aP9cAHPrBUp9TMHRtDhvITn/jE4DauwbW4pmTuQghhTiZkzB3H6Lrrrmse8YhHlOXlL395cbYIZOWS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zXnnndekL4YQhiLyIoQQQj/oiBlbbbXV7IHPIYT5xD333NMsuuiiA59CCKE/kRchhBD6kcxdCPOZROJDCCMl8iKEEEI/SuZu5syZsxdbbLGBr0II85q77767mTVrVnPFFVc06YshhKGIvAghhNAPOiITqoQQQgghhBDCNCDOXQghhBBCCCFMA+LchRBCCCGEEMI0IM5dCCGEEEIIIUwD4tyFEEIIIYQQwjQgzl0IIYQQQgghTAPi3IUQQgghhBDCNCDOXQghhBBCCCFMA+LchRBCCCGEEMI0IM5dCCGEEEIIIUwDpqVz97vf/a4sN9xwQ/l8++23D37317/+tXw3GTh2+7whhBBCCCGEMK+YMXPmzNmLLbbYwMfRw5npx7LLLts8+MEPHvg0b3A9l1xySbPmmms2X/3qV5tXvvKVzfOf//zm0EMPbZZbbrnms5/9bPOBD3ygechDHjKwx9zUe3rQgx40x3b//Oc/m7/97W8Dn+bEtgcccEDz6le/uvn617/e7Lnnns3DH/7wgbXzD/ey6KKLDl4LB/Rf//pX+X+11VYrf8P85e67725mzZrVXHHFFc14+iJ6tdEVVlihWWqppQY+9abbj/WVZZZZZuDTnO2my0iOH0KYGOaXvBAkvfnmmwc+9aarM3vJja5sqQiK3nPPPXPopfrdUESPhRDC/6AjxpW5YxB++9vfbv7xj380f//73wcXAv3qq69u3vCGN8xlNM4L/vOf/zSLLLJI+YvZs2c3Cy20UPOABzxg8Lt+uN5vfetb5T7e8Y53lHup32+//fbNn/70p6Ks2gtn0l/HXmKJJYY9x7yA0nbNl156aXPUUUcVJele3JN7c4/z492EyaNXG/31r3/dPPGJTxzyXVt38cUXD+5jf8ep+2g3Ahd/+ctfSruq2916663Ntdde22yyySbF8AshTB1GIy/0b/1cf9fv6/Z1YQNU/dLWmW9961vL57od53DnnXcucqSNbT/zmc8Uh7Wem86iu2677bY5zmWxv3Nedtllc11rCCHc3xl3WSZHZsaMGc2///3vogAsHKmVV165edvb3tZ86EMfam655ZaBrRdsKCFZvWc+85nNpz71qaKYRCEpD8bv0Ucf3Zx55pklOlmXww8/fIFw5iqev+ultG+66abmMY95THPvvfeWde7FPbk39+heqyIOUxvGzh577FGMocsv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mAbEuQshhBBCCCGEaUCcuxBCCCGEEEKYBsS5CyGEEEIIIYRpQJy7EEIIIYQQQpgGxLkLIYQQQgghhGlAnLsFmH/+85/N7373u7KEEEIIIYQQwlDMmDlz5uzFFlts4OPoGcrxWHTRRZuHP/zh5f977723+ctf/tLceeedc3w/FPb529/+1tx+++0D3/yPBz3oQc1DHvKQgU8LNpw094HVVlut/K0M9fxe85rXNO9973ubK664onnmM585177zg7/+9a/Nv/71r2aFFVZollpqqfJubr755rKufhdGx913393MmjWrvOfx9EW021plJO+l2w6XW265Zplllhn49F96tdUFoU2GcH9ifsmLtqzvB7181113Nffcc8/AN70hN/odbzh5VeXQSO2IEEK4P0FHjCtzR8h++9vfbv7xj380f//73+dYKI0jjzyyueGGG8r6P/zhD82HP/zh5pZbbhn8figoiBtvvLE56KCDml//+tdlP8eliK677rrmgAMOKI7Ggo7nsMMOOzR//vOfizKuism1+/9b3/pWc+uttxaHqS7WffCDH2yuv/76Zokllmjuu+++ss/8xvW+7W1va375y182T3nKU8rnTTbZpPz9zW9+02ywwQY9HfEwb/Aett9+++ZPf/rTYFvSd574xCeWdf2w7uKLLx7cx/6O097H/5dccskcbVXbHeq4IYQFF313pPKCXCfrr7322rn0lYWOp7f233//ot9vu+22ubahC2132WWXleNvtNFGRW+0j3fNNdcMKa98T+7Y9ogjjhjWjgghhPsj4y7L/M9//tPMmDGj+fe//10UwB133FEW//MeRfB23HHH5mc/+1nzile8oll88cWHdVZk7Dh3Z5xxRrPnnns2M2fOLOdxTOfxefnlly/bLOhwRl/3utcVJSTaKmJJQb31rW8t69ZYY41mp512KhHPulCgCy204FTMuvaqVF33Ioss0syePbtEWE899dTmta99bbPkkks2e++997CR3TA5MJz22GOP5qijjmouv/zy0o5e+MIXlvdy9NFHN9tuu21Px9t75bSts846zRvf+Mayn/3t84EPfGAwCCEwsfDCCzdLL7102eakk05qnvWsZ8XBC2EKMlp5IZN27rnnFn1VZUB74RT+/ve/L84dnf3ABz5wrm0+9rGPFVvh7LPPLsfcbLPNSqCwHo/8WXnllZvP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)

The SVM model outperformed the Logistic Regression model in terms of accuracy (82% vs. 78.4%), recall (85% vs. 76.17%), and F1-Score (82% vs. 77.34%). While Logistic Regression provided slightly better precision (78.55% vs. 79% for SVM), the SVM model was more effective in reducing false negatives (154 for SVM vs. 244 for Logistic Regression). Overall, the SVM model demonstrated more balanced and superior performance.

# 2. Support Vector Machine Task  (30 points)

* Define your SVM model using sklearn

## 2.1 implementing svm with grid search cv using all features (10 points)

* Define features and target variable, you will use all features of dataset in this task
"""

X_svm = df.iloc[:, :-1]  # X Features: all columns without the last column
y_svm = df.iloc[:, -1] - 1   # y Target: last column (with normalization)

# Display first few rows of the features and target variable
print(X_svm.head())
print(y_svm.head())

"""* Split the dataset into a training set and a validation set (80% training and 20% validation)."""

X_train_svm, X_val_svm, y_train_svm, y_val_svm = train_test_split(X_svm, y_svm, test_size=0.2, random_state=42)

print(f"Train set: {X_train_svm.shape}, {y_train_svm.shape}\nTest set: {X_val_svm.shape}, {y_val_svm.shape}")

"""* Scale the features using StandardScaler"""

scaler = StandardScaler()

X_train_svm = scaler.fit_transform(X_train_svm)
X_val_svm = scaler.transform(X_val_svm)

print("Features are standardized.")

"""#### Implement GridSearchCV  (5 points)"""

from sklearn.svm import SVC
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import classification_report, confusion_matrix

"""* Initialize the SVM classifier"""

svm_model = SVC()

"""* Train the SVM classifier with the best parameters found from grid search

"""

# Define the parameter grid to search
param_grid = {
    'C': [0.1, 1, 10],               # Regularization parameter
    'kernel': ['linear', 'rbf'],     # Types of kernel
    'gamma': ['scale', 'auto', 0.1]  # Kernel coefficient for 'rbf', 'poly', and 'sigmoid'
}

# Initialize GridSearchCV with the SVM model and parameter grid
grid_search = GridSearchCV(estimator=svm_model, param_grid=param_grid,
                           cv=5, n_jobs=-1, verbose=1, scoring='accuracy')
# Fit the GridSearchCV to the training data
grid_search.fit(X_train_svm, y_train_svm)

# Print the best parameters found by GridSearchCV
best_params = grid_search.best_params_
best_score = grid_search.best_score_

print(f"Best Hyperparameters: {best_params}")
print(f"Best Cross-Validation Accuracy: {best_score:.4f}")

"""* Make predictions on the validation set using the best model

"""

# Get the best model from GridSearchCV
best_svm_model = grid_search.best_estimator_

# Make predictions on the validation set
y_pred_svm = best_svm_model.predict(X_val_svm)

# Display first few predictions
print(f"Predictions on Validation Set: {y_pred_svm[:10]}")

"""#### Evaluate the model's performance, print classification report and confusion matrix and best parameters found from GridSearchCV  (5 points)"""

# Print the classification report
print("\nClassification Report:")
print(classification_report(y_val_svm, y_pred_svm))

# Print the confusion matrix
print("\nConfusion Matrix:")
print(confusion_matrix(y_val_svm, y_pred_svm))

# Display the best parameters found from GridSearchCV
print("\nBest Parameters from GridSearchCV:")
print(grid_search.best_params_)

"""## 2.2 implementing svm with most correlated 2 features (10 points)

#### Choose the two most correlated features with target feature 'y'
"""

X_svm_mst = df[["duration", "poutcome"]]
y_svm_mst = df['y'] - 1 # with normalization

"""* Split the dataset into a training set and a validation set (80% training and 20% validation)."""

X_train_svm_mst, X_val_svm_mst, y_train_svm_mst, y_val_svm_mst = train_test_split(X_svm_mst, y_svm_mst, test_size=0.2, random_state=42)

print(f"Train set: {X_train_svm_mst.shape}, {y_train_svm_mst.shape}\nTest set: {X_val_svm_mst.shape}, {y_val_svm_mst.shape}")

"""* Scale the features using StandardScaler"""

scaler = StandardScaler()

X_train_svm_mst = scaler.fit_transform(X_train_svm_mst)

X_val_svm_mst = scaler.transform(X_val_svm_mst)

print("Features are standardized.")

"""*  Initialize the SVM classifier, assign 'C' and 'kernel' parameters from the best hyperparameters you found from GridSearchCV"""

# Use the best parameters found from 2.1
best_params = {
    'C': 0.1,         # Regularization parameter
    'gamma': 'scale', # Kernel coefficient
    'kernel': 'rbf'   # Kernel type
}

# Initialize the SVM classifier with the best parameters
svm_model_mst = SVC(C=best_params['C'], gamma=best_params['gamma'], kernel=best_params['kernel'])

# Display the initialized model
print(f"SVM Model initialized with C={best_params['C']}, gamma={best_params['gamma']}, kernel={best_params['kernel']}")

"""* Train the SVM classifier"""

svm_model_mst.fit(X_train_svm_mst, y_train_svm_mst)

print("SVM Model trained successfully.")

"""* Make predictions on the validation set"""

y_pred_svm_mst = svm_model_mst.predict(X_val_svm_mst)

print(f"Predictions on the validation set: {y_pred_svm_mst[:10]}")

"""#### Evaluate the model's performance, print classification report and confusion matrix  (5 points)"""

print("\nClassification Report:")
print(classification_report(y_val_svm_mst, y_pred_svm_mst))

print("\nConfusion Matrix:")
print(confusion_matrix(y_val_svm_mst, y_pred_svm_mst))

"""##### Visualize decision boundary and support vectors (5 points)"""

import numpy as np
import matplotlib.pyplot as plt

def plot_svm_decision_boundary(X, y, model, scaler):
    """
    X: Scaled features (numpy array)
    y: Target variable
    model: Trained SVM model
    scaler: StandardScaler object used to scale X
    """
    # Create meshgrid for decision boundary visualization
    x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1
    y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1
    xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.01),
                         np.arange(y_min, y_max, 0.01))

    # Standardize the meshgrid points
    grid_points = np.c_[xx.ravel(), yy.ravel()]
    grid_points_scaled = scaler.transform(grid_points)  # Scale the grid points

    # Predict class for each point on the grid
    Z = model.predict(grid_points_scaled)
    Z = Z.reshape(xx.shape)  # Reshape predictions for contour plotting

    # Plot decision boundary
    plt.figure(figsize=(10, 6))
    plt.contourf(xx, yy, Z, alpha=0.3, cmap=plt.cm.coolwarm)  # Decision boundary regions

    # Plot data points
    plt.scatter(X[:, 0], X[:, 1], c=y, s=40, cmap=plt.cm.coolwarm, edgecolors='k')

    # Highlight support vectors
    support_vectors = model.support_vectors_
    plt.scatter(support_vectors[:, 0], support_vectors[:, 1], s=100, facecolors='none', edgecolors='k', linewidth=1.5)

    # Add labels and title
    plt.title("SVM Decision Boundary and Support Vectors")
    plt.xlabel("Feature: duration")
    plt.ylabel("Feature: poutcome")
    plt.show()

# Call the function to visualize decision boundary
plot_svm_decision_boundary(X_train_svm_mst, y_train_svm_mst, svm_model_mst, scaler)

"""## 2.3 implementing svm with least correlated 2 features (10 points)

#### Choose the two least correlated features with target feature 'y'
"""

X_svm_least = df[["month", "job"]]
y_svm_least = df['y'] - 1 # with normalization

"""* Split the dataset into a training set and a validation set (80% training and 20% validation)."""

X_train_svm_least, X_val_svm_least, y_train_svm_least, y_val_svm_least = train_test_split(X_svm_least, y_svm_least, test_size=0.2, random_state=42)

print(f"Train set: {X_train_svm_least.shape}, {y_train_svm_least.shape}\nTest set: {X_val_svm.shape}, {y_val_svm.shape}")

"""* Scale the features using StandardScaler"""

scaler = StandardScaler()

X_train_svm_least = scaler.fit_transform(X_train_svm_least)

X_val_svm_least = scaler.transform(X_val_svm_least)

print("Features are standardized.")

"""*  Initialize the SVM classifier, assign 'C' and 'kernel' parameters from the best hyperparameters you found from GridSearchCV"""

# Use the best parameters found from 2.1
best_params = {
    'C': 0.1,         # Regularization parameter
    'gamma': 'scale', # Kernel coefficient
    'kernel': 'rbf'   # Kernel type
}

# Initialize the SVM classifier with the best parameters
svm_model_least = SVC(C=best_params['C'], gamma=best_params['gamma'], kernel=best_params['kernel'])

# Display the initialized model
print(f"SVM Model initialized with C={best_params['C']}, gamma={best_params['gamma']}, kernel={best_params['kernel']}")

"""* Train the SVM classifier"""

svm_model_least.fit(X_train_svm_least, y_train_svm_least)

print("SVM Model trained successfully.")

"""* Make predictions on the validation set"""

y_pred_svm_least = svm_model_least.predict(X_val_svm_least)

print(f"Predictions on the validation set: {y_pred_svm_least[:10]}")

"""#### Evaluate the model's performance, print classification report and confusion matrix  (5 points)"""

print("\nClassification Report:")
print(classification_report(y_val_svm_least, y_pred_svm_least))

print("\nConfusion Matrix:")
print(confusion_matrix(y_val_svm_least, y_pred_svm_least))

"""##### Visualize decision boundary and support vectors(5 points)"""

import numpy as np
import matplotlib.pyplot as plt

def plot_svm_decision_boundary(X, y, model, scaler):
    """
    X: Scaled features (numpy array)
    y: Target variable
    model: Trained SVM model
    scaler: StandardScaler object used to scale X
    """
    # Create meshgrid for decision boundary visualization
    x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1
    y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1
    xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.01),
                         np.arange(y_min, y_max, 0.01))

    # Standardize the meshgrid points
    grid_points = np.c_[xx.ravel(), yy.ravel()]
    grid_points_scaled = scaler.transform(grid_points)  # Scale the grid points

    # Predict class for each point on the grid
    Z = model.predict(grid_points_scaled)
    Z = Z.reshape(xx.shape)  # Reshape predictions for contour plotting

    # Plot decision boundary
    plt.figure(figsize=(10, 6))
    plt.contourf(xx, yy, Z, alpha=0.3, cmap=plt.cm.coolwarm)  # Decision boundary regions

    # Plot data points
    plt.scatter(X[:, 0], X[:, 1], c=y, s=40, cmap=plt.cm.coolwarm, edgecolors='k')

    # Highlight support vectors
    support_vectors = model.support_vectors_
    plt.scatter(support_vectors[:, 0], support_vectors[:, 1], s=100, facecolors='none', edgecolors='k', linewidth=1.5)

    # Add labels and title
    plt.title("SVM Decision Boundary and Support Vectors (Least Correlated Features)")
    plt.xlabel("Feature: month")
    plt.ylabel("Feature: job")
    plt.show()

# Call the function to visualize decision boundary
plot_svm_decision_boundary(X_train_svm_least, y_train_svm_least, svm_model_least, scaler)

"""# 3. Decision Tree Task (30 points)

* Define your decision tree model using sklearn. Also you should define other necessary modules for visualize the decision tree

### Download the dataset from https://drive.google.com/file/d/1D3peA-TzIqJqZDDKTlK0GQ7Ya6FIemFv/view?usp=sharing

### import other necessary libraries
"""

df=pd.read_csv("weights_bmi_6classes_updated.csv", encoding="utf-8")

"""* Define features and target variable, you will use all features of dataset in this task"""

X_tree = df.iloc[:, :-1]
y_tree = df.iloc[:, -1] - 1   # with normalization

"""* Split the dataset into a training set and a validation set (80% training and 20% validation)."""

X_train_tree, X_val_tree, y_train_tree, y_val_tree = train_test_split(X_tree, y_tree, test_size=0.2, random_state=42)

print(f"Train set: {X_train_tree.shape}, {y_train_tree.shape}\nTest set: {X_val_tree.shape}, {y_val_tree.shape}")

"""* Initialize the Decision Tree classifier"""

from sklearn.tree import DecisionTreeClassifier, plot_tree

dt_classifier = DecisionTreeClassifier(random_state=42)

print(f"Decision Tree Classifier initialized: {dt_classifier}")

"""* Train the Decision Tree classifier"""

# Train the Decision Tree classifier with the training data
dt_classifier.fit(X_train_tree, y_train_tree)

print("Decision Tree model trained successfully.")

"""* Make predictions on the validation set"""

# Make predictions on the validation set
y_pred_tree = dt_classifier.predict(X_val_tree)

print(f"Predictions on Validation Set: {y_pred_tree[:10]}")

"""#### Evaluate the model's performance, print classification report and confusion matrix  (10 points)"""

# Print the classification report to evaluate the model's performance
print("\nClassification Report:")
print(classification_report(y_val_tree, y_pred_tree))

# Print the confusion matrix to evaluate the model's performance in more detail
print("\nConfusion Matrix:")
print(confusion_matrix(y_val_tree, y_pred_tree))

"""#### Visualize the Decision Tree, show clearly class number, gini value etc.  (10 points)

"""

# Visualize the Decision Tree
plt.figure(figsize=(20,10))  # Set the figure size for the tree
plot_tree(dt_classifier,
          filled=True,
          feature_names=X_tree.columns,
          class_names=[str(i) for i in range(4)],  # Display class numbers (adjust to your classes)
          rounded=True,
          proportion=False,
          precision=2,
          fontsize=12)

# Show the plot
plt.show()

"""### Explain briefly the question. What is the role of gini in decision tree? (10 points)

The Gini Index measures the impurity or homogeneity of a dataset and plays a key role in decision trees by determining the best feature and threshold for splitting nodes. A Gini value of 0 indicates pure nodes (all samples belong to a single class), while higher values indicate more mixed classes. At each step, the decision tree algorithm selects the split that minimizes the Gini impurity, creating child nodes that are as homogeneous as possible. This process continues recursively, helping the tree to better classify the data while reducing uncertainty.
"""